## DIP - 의존관계 역전법칙(Dependency inversion Principle)

------

#### 추상화 된 것은 구체적인 것에 의존하면 안되고 구체적인 것이 추상화된 것에 의존해야 한다

위에서는 **변할수 있는것**  과 **변하지 않을 것** 을 나누는 게 중요했다.

그리고 **구체적일 수록 잘 변했고** , **구제적이지 않을 수록 잘 변하지 않았다.**



객체사이의 서로 도움을 주고 받으면서 협력을 하게 되면  어쩔수 없이 의존관계가 생길 수밖에 없다.

```swift
struct 평범한움직임{
    func 이동하다() {
        print("🐾")
    }
    
    func 점프하다() {
        print("💨")
    }
}
```

```swift
struct 고양이 {
    let 움직이는전략: 평범한움직임  // 구체 클래스
    
    func 이동하기(){
        움직이는전략.이동하다()
    }
    
    func 점프하기(){
        움직이는전략.점프하다()
    }
}
```

위의 예제와 비슷하겠지만 , `고양이` 는구체적인 `평범한움직임`이라는 구조체에 의존하고있다. 구체적인 클래스는 변화에 취약하다.

그 과정에서 **의존성을 역전** 시키기위 한 방법은 **의존하는 클래스를 덜 구체적인 클래스**로 하는 것이다. 

```swift
protocol 움직이는방법 {
    func 이동하다()
    func 점프하다()
}
/
struct 평범한움직임: 움직이는방법{
    func 이동하다() {
        print("🐾")
    }
    
    func 점프하다() {
        print("💨")
    }
}
```

변하지 않을 부분을 선언해둠으로써 , 구체적인 타입을 포함할 수 있게 추상적인 타입을 선언해보자



```swift
struct 고양이 {
    let 움직이기전략: 움직이는방법  // 구체적이지 않은 클래스에 의존
    
    func 이동하기(){
        움직이기전략.이동하다()
    }
    
    func 점프하기(){
        움직이기전략.점프하다()
    }
  //DI - 의존성주입
  mutating	func 움직이는방법바꾸기(_ 새로운움직이기전략:움직이는방법){
      self.움직이기전략 = 새로운움직이기전략
    }
}
```

이렇게 구체적이지 않은 타입으로 바뀌면서 의존하는 클래스를 외부에서도 쉽게 넣어줌으로써 , 

런타임에서도 동작을 변경시킬수 있는 유연한 코드가 되었다.

```swift
struct 재빠른움직임: 움직이는방법{
    func 이동하다() {
        print("🐾🐾🐾🐾🐾🐾")
    }
    
    func 점프하다() {
        print("💨💨💨💨💨💨")
    }
}
```

```swift
let 🐈 = 고양이()
🐈.움직이는방법바꾸기(평범한움직임())
🐈.이동하기() //  Print 🐾
🐈.움직이는방법바꾸기(재빠른움직임())
🐈.이동하기() //  Print 🐾🐾🐾🐾🐾🐾
```

이렇게 추상적인 타입에 의존하게 됨으로써 , **의존성주입**을 통한 유연한 코드도 가능해졌다.

의존성역전을 통해 의존성주입이라는 이점을 취할수 있게 된 예이다.

#### 위의 예시는 **''스트래티지패턴''** 을 이용했다 . 공부해보자

